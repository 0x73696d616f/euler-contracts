Exec
  * figure out how/if flash loans will work with batch dispatch
  * pass data callback through onDeferredLiquidityCheck() so contract can avoid putting transient data in storage
  ? in batch dispatch, returning values probably doesn't make sense. use logs instead
  ? method to do a uniswap swap so rebalancing can be done in a batch (EToken -> EToken, from perspective of user)
  g reentrancy guard: try using 1,2 instead of 1,0 (OZ code says this is better so as to keep refund low)
  * tests
    * test that internal modules cannot be called through dispatcher or batch dispatch
    * failure cases in batch
    * onDeferredLiquidity
    * logs sent through proxy ok
    * hitting max entered markets, re-exiting already exited market
    * reentrancy guard

Lending logic:
  g when a token has < 18 decimal places, and a user withdraws their full EToken balance, 0 out the remaining dust so user gets a storage refund
  ? log Transfer event when DToken accrues interest (necessary to accurately track balance, but adds gas to almost every operation)
  ? move EToken/DToken Transfer logs into increaseBalance, etc (cleaner code, but maybe higher gas usage because needs to load proxy addr)
  * tests
    ! more subAccount tests
    ! tests that hit max sane amounts
    * token with collateral factor=0 doesn't contribute to your collateral
    * tests for eWETH

Pricing:
  ? split out the updates to cardinality so the view can actually be a view (instead of requiring callStatic)
  ? emit log when we increase uniswap observation cardinality?
  ? how to determine which uniswap pool (fee-level) to use when market activated? check liquidity?
  * tests
    ! fill out stubs in MockUniswapV3Pool
    ! oldest prices
    ! observation ring buffer sizing

Governance/Installer
  * way for governance to switch uniswap fee pool
  * tests
    * update asset config (collateral/borrow factors, borrow isolation)
    * changing governor admin, make sure only governor admin can call gov functions

Liquidity
  !! important: if max sane prices are exceeded in liquidity check, saturate instead of failing (so attacker can't cause checkLiquidity to fail)
  ! basic liquidation bot
  * tests
    ! misbehaving tokens
      * failing balanceOf (bad return, out of gas, self destruct)
      * if balanceOf(euler) suddenly goes to 0, balanceOfUnderlying()s of all EToken holders go to 0 too
    ! borrow isolation when combined with non-isolated assets
    * liquidation:
      * partial repayments
      * exercise when all collateral is taken -- failure possible due to rounding during conversion?
      * discount levels, profitability as price moves
      * when repay is limited to current owed, or by borrower's collateral

Interest rate models
  ! implement Michael's algo
  ! worst case caps for interest rates (in case of buggy models)
  ? PID controller
  * tests
    * negative IR

Tokens
  ? implement permit() on E/DTokens
  ? implement increase/decreaseAllowance on E/DTokens
  ? emit Approval events on transfers inside E/DTokens if allowance updated (adds gas, but may be useful to somebody)

Test infrastructure
  ! Test module upgrades



Invariants to add
  * If a user has a non-zero borrow owed:
    * they must be entered into market
    * must have a non-zero interest accumulator
  * If totalBorrows > 0, must have a non-zero interest accumulator

Pre-release checklist
  * FIXMEs
  * Make sure nothing is done in module constructors except set immutable variables, and modules have no storage variables
  * All methods that take 2 addresses should verify they aren't == (self liquidations/transfers/approvals)
  * Verify every external/public, non-view/pure function in a module is marked nonReentrant
    * Some functions don't need reentrancy guard, ie: approve()
  * No accidental external methods inherited (nothing external/public in the Base classes, except moduleId)
  * Storage layout consistent between releases
  * Make sure "msg.sender" not present in contracts/modules/
